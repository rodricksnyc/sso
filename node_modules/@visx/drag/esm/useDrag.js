function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useCallback, useEffect, useRef, useState } from 'react';
import { localPoint } from '@visx/event';
import useStateWithCallback from './util/useStateWithCallback';
import clampNumber from './util/clampNumber';

/** Hook for dragging, returns a `UseDrag` object. */
export default function useDrag(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$resetOnStart = _ref.resetOnStart,
      resetOnStart = _ref$resetOnStart === void 0 ? false : _ref$resetOnStart,
      _ref$snapToPointer = _ref.snapToPointer,
      snapToPointer = _ref$snapToPointer === void 0 ? true : _ref$snapToPointer,
      onDragEnd = _ref.onDragEnd,
      onDragMove = _ref.onDragMove,
      onDragStart = _ref.onDragStart,
      x = _ref.x,
      y = _ref.y,
      dx = _ref.dx,
      dy = _ref.dy,
      isDragging = _ref.isDragging,
      _ref$restrict = _ref.restrict,
      restrict = _ref$restrict === void 0 ? {} : _ref$restrict;

  // use ref to detect prop changes
  var positionPropsRef = useRef({
    x: x,
    y: y,
    dx: dx,
    dy: dy
  });
  var xMin = restrict.xMin,
      xMax = restrict.xMax,
      yMin = restrict.yMin,
      yMax = restrict.yMax;
  var clampX = useCallback(function (num) {
    return clampNumber(num, xMin != null ? xMin : -Infinity, xMax != null ? xMax : Infinity);
  }, [xMax, xMin]);
  var clampY = useCallback(function (num) {
    return clampNumber(num, yMin != null ? yMin : -Infinity, yMax != null ? yMax : Infinity);
  }, [yMax, yMin]);

  var _useStateWithCallback = useStateWithCallback({
    x: x,
    y: y,
    dx: dx != null ? dx : 0,
    dy: dy != null ? dy : 0,
    isDragging: false
  }),
      dragState = _useStateWithCallback[0],
      setDragStateWithCallback = _useStateWithCallback[1]; // Track distance between pointer on dragStart and position of element being dragged


  var _useState = useState({
    x: 0,
    y: 0
  }),
      dragStartPointerOffset = _useState[0],
      setDragStartPointerOffset = _useState[1]; // if prop position changes, update state


  useEffect(function () {
    if (positionPropsRef.current.x !== x || positionPropsRef.current.y !== y || positionPropsRef.current.dx !== dx || positionPropsRef.current.dy !== dy) {
      positionPropsRef.current = {
        x: x,
        y: y,
        dx: dx,
        dy: dy
      };
      setDragStateWithCallback(function (currState) {
        return _extends({}, currState, {
          x: x,
          y: y,
          dx: dx != null ? dx : 0,
          dy: dy != null ? dy : 0
        });
      });
    }
  });
  useEffect(function () {
    if (isDragging !== undefined && dragState.isDragging !== isDragging) {
      setDragStateWithCallback(function (currState) {
        return _extends({}, currState, {
          isDragging: isDragging
        });
      });
    }
  }, [dragState.isDragging, isDragging, setDragStateWithCallback]);
  var handleDragStart = useCallback(function (event) {
    event.persist();
    setDragStateWithCallback(function (currState) {
      var currentPoint = {
        x: (currState.x || 0) + currState.dx,
        y: (currState.y || 0) + currState.dy
      };
      var eventPoint = localPoint(event) || {
        x: 0,
        y: 0
      };
      var point = snapToPointer ? eventPoint : currentPoint;
      setDragStartPointerOffset({
        x: currentPoint.x - eventPoint.x,
        y: currentPoint.y - eventPoint.y
      });
      return {
        isDragging: true,
        dx: resetOnStart ? 0 : currState.dx,
        dy: resetOnStart ? 0 : currState.dy,
        x: resetOnStart ? clampX(point.x) : clampX(point.x) - currState.dx,
        y: resetOnStart ? clampY(point.y) : clampY(point.y) - currState.dy
      };
    }, onDragStart && function (currState) {
      onDragStart(_extends({}, currState, {
        event: event
      }));
    });
  }, [clampX, clampY, onDragStart, resetOnStart, setDragStateWithCallback, snapToPointer]);
  var handleDragMove = useCallback(function (event) {
    event.persist();
    setDragStateWithCallback(function (currState) {
      var point = localPoint(event) || {
        x: 0,
        y: 0
      };
      return currState.isDragging ? _extends({}, currState, {
        isDragging: true,
        dx: snapToPointer ? clampX(point.x) - (currState.x || 0) : clampX(point.x + dragStartPointerOffset.x) - (currState.x || 0),
        dy: snapToPointer ? clampY(point.y) - (currState.y || 0) : clampY(point.y + dragStartPointerOffset.y) - (currState.y || 0)
      }) : currState;
    }, onDragMove && function (currState) {
      if (currState.isDragging) onDragMove(_extends({}, currState, {
        event: event
      }));
    });
  }, [setDragStateWithCallback, onDragMove, snapToPointer, dragStartPointerOffset.x, dragStartPointerOffset.y, clampX, clampY]);
  var handleDragEnd = useCallback(function (event) {
    event.persist();
    setDragStateWithCallback(function (currState) {
      return _extends({}, currState, {
        isDragging: false
      });
    }, onDragEnd && function (currState) {
      onDragEnd(_extends({}, currState, {
        event: event
      }));
    });
  }, [onDragEnd, setDragStateWithCallback]);
  return _extends({}, dragState, {
    dragEnd: handleDragEnd,
    dragMove: handleDragMove,
    dragStart: handleDragStart
  });
}