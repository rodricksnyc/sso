"use strict";

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Table = void 0;

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.object.from-entries.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.object.entries.js");

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _get = _interopRequireDefault(require("lodash/get"));

var _reduce = _interopRequireDefault(require("lodash/reduce"));

var _has = _interopRequireDefault(require("lodash/has"));

var _isArray = _interopRequireDefault(require("lodash/isArray"));

var _components = require("@looker/components");

var _visualizationsAdapters = require("@looker/visualizations-adapters");

var _TableMeasure = require("./TableMeasure");

var _numeral = _interopRequireDefault(require("numeral"));

var _reactI18next = require("react-i18next");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const getMinMax = (key, data) => {
  return (0, _reduce.default)(data, (minMax, d) => {
    const value = d[key];
    return {
      max: Math.max(minMax.max, value),
      min: Math.min(minMax.min, value)
    };
  }, {
    max: 0,
    min: Infinity
  });
};

const Table = ({
  data = [],
  config,
  fields = {
    dimensions: [],
    measures: []
  },
  totals = {},
  width = 'auto'
}) => {
  const _useTranslation = (0, _reactI18next.useTranslation)('Table'),
        t = _useTranslation.t;

  const theme = (0, _react.useContext)(_styledComponents.ThemeContext);

  if (!data.length) {
    return null;
  }

  const truncateText = config.truncate_text;
  const fieldLabels = Object.fromEntries([...fields.measures, ...fields.dimensions].map((f, i) => {
    const series = (0, _isArray.default)(config.series) ? (0, _get.default)(config, ['series', i]) : (0, _get.default)(config, ['series', f.name]);
    const label = (series === null || series === void 0 ? void 0 : series.label) || f.pivoted_label || f.label_short;
    return [f.name, label];
  }));
  const cellVis = (0, _reduce.default)((0, _get.default)(config, 'series', {}), (acc, {
    cell_visualization
  }, key) => {
    var _fields$measures$pars;

    const measureName = Number.isInteger(key) ? (_fields$measures$pars = fields.measures[parseInt(key)]) === null || _fields$measures$pars === void 0 ? void 0 : _fields$measures$pars.name : key;
    const cell = cell_visualization ? {
      [measureName]: getMinMax(measureName, data)
    } : {};
    return _objectSpread(_objectSpread({}, acc), cell);
  }, {});
  const formattedData = data.map(d => {
    return Object.fromEntries(Object.entries(d).map(([key, value]) => {
      const matchingMeasureIndex = fields.measures.findIndex(measure => measure.name === key);
      const seriesConfig = (0, _isArray.default)(config.series) ? (0, _get.default)(config, ['series', matchingMeasureIndex]) : (0, _get.default)(config, ['series', key]);

      const _ref = seriesConfig || {},
            value_format = _ref.value_format,
            color = _ref.color;

      const isNumericValue = typeof value === 'number' || typeof value === 'string' && (0, _visualizationsAdapters.isNumeric)(value);
      const valueFormatted = isNumericValue && value_format ? (0, _numeral.default)(value).format(value_format) : value;
      const cellVisEntry = cellVis[key];
      const formattedValue = cellVisEntry ? () => _react.default.createElement(_TableMeasure.TableMeasure, {
        value: value,
        valueFormatted: valueFormatted,
        min: cellVisEntry.min,
        max: cellVisEntry.max,
        color: color
      }) : valueFormatted;
      return [key, formattedValue];
    }));
  });
  const resultKeys = Array.isArray(data) ? Object.keys(data[0]) : Object.keys(data);
  return _react.default.createElement(_components.Table, {
    width: width === 'auto' ? '100%' : `${width}px`,
    "data-testid": "table-chart"
  }, _react.default.createElement(_components.TableHead, null, _react.default.createElement(_components.TableRow, null, _react.default.createElement(_components.TableHeaderCell, null), resultKeys.map(key => _react.default.createElement(StyledTableHeaderCell, {
    key: key,
    width: (0, _has.default)(cellVis, key) ? '30%' : 'auto'
  }, fieldLabels[key])))), _react.default.createElement(_components.TableBody, null, Array.isArray(data) && formattedData.map((obj, i) => {
    return _react.default.createElement(StyledTableRow, {
      key: i,
      backgroundColor: i % 2 ? theme.colors.ui1 : theme.colors.background
    }, _react.default.createElement(StyledTableDataCell, {
      textAlign: "right",
      color: "text1",
      width: "1px",
      pr: "small"
    }, i + 1), resultKeys.map(key => {
      const val = obj[key];
      let valHelper = val;

      if (typeof val === 'function') {
        valHelper = val();
      } else if (Object(val) === val) {
        valHelper = JSON.stringify(val);
      }

      return _react.default.createElement(StyledTableDataCell, {
        key: key
      }, truncateText ? _react.default.createElement(_components.Truncate, null, valHelper) : valHelper);
    }));
  }), Object.keys(totals).length > 0 && _react.default.createElement(_components.TableRow, null, _react.default.createElement(StyledTableDataCell, {
    textAlign: "right",
    color: "text1",
    width: "1px",
    pr: "small"
  }, t('Totals')), resultKeys.map(key => {
    const val = totals[key];
    return _react.default.createElement(StyledTableDataCell, {
      key: key
    }, val);
  }))));
};

exports.Table = Table;
const StyledTableHeaderCell = (0, _styledComponents.default)(_components.TableHeaderCell).withConfig({
  displayName: "Table__StyledTableHeaderCell",
  componentId: "sc-1kzwowz-0"
})(["&:first-child{max-width:0;min-width:0;}padding:", ";"], ({
  theme
}) => theme.space.xsmall);
const StyledTableRow = (0, _styledComponents.default)(_components.TableRow).withConfig({
  displayName: "Table__StyledTableRow",
  componentId: "sc-1kzwowz-1"
})(["background:", ";"], ({
  backgroundColor
}) => backgroundColor);
const StyledTableDataCell = (0, _styledComponents.default)(_components.TableDataCell).withConfig({
  displayName: "Table__StyledTableDataCell",
  componentId: "sc-1kzwowz-2"
})(["font-size:", ";max-width:500px;overflow-wrap:break-word;position:relative;", "{left:0;padding:", ";position:absolute;top:0;}"], ({
  theme
}) => theme.fontSizes.medium, _components.Truncate, ({
  theme
}) => theme.space.xsmall);
//# sourceMappingURL=Table.js.map