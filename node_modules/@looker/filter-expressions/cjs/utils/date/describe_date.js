"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.describeDate = void 0;

var _i18next = _interopRequireDefault(require("i18next"));

var _defaultTo = _interopRequireDefault(require("lodash/defaultTo"));

var _describe_null = require("../summary/describe_null");

var _describe_user_attribute = require("../user_attribute/describe_user_attribute");

var _convert_to_number = require("./convert_to_number");

var _date_conversions = require("./date_conversions");

var _format_time = require("./format_time");

var _get_months = require("./get_months");

var _get_unit_label = require("./get_unit_label");

var _is_date_time = require("./is_date_time");

var _zero_pad = require("./zero_pad");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const describeDateTime = ({
  year,
  month,
  day,
  hour = 0,
  minute = 0
}, showTime) => {
  let result = String((0, _zero_pad.zeroPad4)(year));
  result += month ? `/${(0, _zero_pad.zeroPad2)(month)}` : '';
  result += day ? `/${(0, _zero_pad.zeroPad2)(day)}` : '';

  if (showTime) {
    result += ` ${(0, _format_time.formatAndDisplayTime)({
      hour: (0, _convert_to_number.convertToNumber)(hour.toString()),
      minute,
      meridiem: (0, _format_time.meridiemFrom24HourTime)(hour)
    })}`;
  }

  return result;
};

const describeInterval = ({
  value,
  unit,
  complete
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  const result = t('value complete unitLabel', {
    ns: 'describe_date',
    value,
    complete: complete ? t(' complete', {
      ns: 'describe_date'
    }) : '',
    unitLabel: (0, _get_unit_label.getUnitLabel)(unit, value)
  });
  return result;
};

const describeNotNull = () => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is not null', {
    ns: 'describe_date'
  });
};

const past = item => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is in the last', {
    ns: 'describe_date',
    describeInterval: describeInterval(item)
  });
};

const describePastAgo = item => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is interval ago', {
    ns: 'describe_date',
    interval: describeInterval(item)
  });
};

const describeTypeAndUnit = ({
  type,
  unit
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  const thisText = t('this', {
    ns: 'describe_date'
  });
  const nextText = t('next', {
    ns: 'describe_date'
  });
  return t('is type unitLabel', {
    ns: 'describe_date',
    type: type === 'this' ? thisText : nextText,
    unitLabel: (0, _get_unit_label.getUnitLabel)(unit)
  });
};

const describeLast = ({
  unit
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is previous unitLabel', {
    ns: 'describe_date',
    unitLabel: (0, _get_unit_label.getUnitLabel)(unit)
  });
};

const describeYear = ({
  year
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is in the year year', {
    ns: 'describe_date',
    year
  });
};

const describeMonth = ({
  month,
  year
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is in month year', {
    ns: 'describe_date',
    month: (0, _get_months.getMonths)()[parseInt(month, 10) - 1],
    year
  });
};

const beforeAfter = (item, showTime) => {
  const t = _i18next.default.t.bind(_i18next.default);

  const type = item.type,
        range = item.range,
        date = item.date,
        fromnow = item.fromnow;
  const prefix = type === 'after' ? t('is on or after', {
    ns: 'describe_date'
  }) : t('is before', {
    ns: 'describe_date'
  });

  if (range === 'absolute') {
    return t('absolute prefix dateTime', {
      ns: 'describe_date',
      prefix,
      dateTime: describeDateTime(date, showTime)
    });
  }

  const timePassed = fromnow ? t('from now', {
    ns: 'describe_date'
  }) : t('ago', {
    ns: 'describe_date'
  });
  return item.unit === 'now' ? t('prefix now', {
    ns: 'describe_date',
    prefix
  }) : t('prefix interval timePassed', {
    ns: 'describe_date',
    prefix,
    interval: describeInterval(item),
    timePassed
  });
};

const on = ({
  date
}, showTime) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is on dateTime', {
    ns: 'describe_date',
    dateTime: describeDateTime(date, showTime && (0, _date_conversions.hasTimeFilterDateTimeModel)(date))
  });
};

const describeRange = ({
  start,
  end
}, showTime) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is from dateTimeStart until dateTimeEnd', {
    ns: 'describe_date',
    dateTimeStart: describeDateTime(start, showTime),
    dateTimeEnd: describeDateTime(end, showTime)
  });
};

const describeThisRange = ({
  startInterval,
  endInterval
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('this startInterval to endInterval', {
    ns: 'describe_date',
    startInterval,
    endInterval
  });
};

const relative = ({
  startInterval,
  endInterval,
  intervalType
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  const agoText = t('ago', {
    ns: 'describe_date'
  });
  const fromNowText = t('from now', {
    ns: 'describe_date'
  });
  return t('is intervalStart intervalType for intervalEnd', {
    ns: 'describe_date',
    intervalStart: describeInterval(startInterval),
    intervalType: intervalType === 'ago' ? agoText : fromNowText,
    intervalEnd: describeInterval(endInterval)
  });
};

const anyvalue = () => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is any time', {
    ns: 'describe_date'
  });
};

const describeDay = ({
  day
}) => {
  const t = _i18next.default.t.bind(_i18next.default);

  return t('is day', {
    ns: 'describe_date',
    day
  });
};

const filterToStringMap = {
  null: _describe_null.describeNull,
  notnull: describeNotNull,
  pastAgo: describePastAgo,
  past,
  this: describeTypeAndUnit,
  next: describeTypeAndUnit,
  last: describeLast,
  year: describeYear,
  month: describeMonth,
  before: beforeAfter,
  after: beforeAfter,
  range: describeRange,
  thisRange: describeThisRange,
  on,
  relative,
  anyvalue,
  user_attribute: _describe_user_attribute.describeUserAttribute,
  day: describeDay
};

const describeDate = (item, expressionType) => (0, _defaultTo.default)(filterToStringMap[item.type], () => '')(item, (0, _is_date_time.isDateTime)(expressionType));

exports.describeDate = describeDate;
//# sourceMappingURL=describe_date.js.map