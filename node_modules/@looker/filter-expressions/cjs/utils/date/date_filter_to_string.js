"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dateFilterToString = void 0;

var _user_attribute_to_string = require("../user_attribute/user_attribute_to_string");

var _null_item_to_string = _interopRequireDefault(require("../to_string/null_item_to_string"));

var _tree_to_string = require("../tree/tree_to_string");

var _is_date_time = require("./is_date_time");

var _zero_pad = require("./zero_pad");

var _date_conversions = require("./date_conversions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const datetime = ({
  year,
  month,
  day,
  hour,
  minute
}, showTime) => {
  let result = String((0, _zero_pad.zeroPad4)(year));
  result += month ? `/${(0, _zero_pad.zeroPad2)(month)}` : '';
  result += day ? `/${(0, _zero_pad.zeroPad2)(day)}` : '';

  if (showTime) {
    result += hour !== undefined ? ` ${(0, _zero_pad.zeroPad2)(hour)}` : '';
    result += minute !== undefined ? `:${(0, _zero_pad.zeroPad2)(minute)}` : '';
  }

  return result;
};

const beforeAfter = (item, showTime) => {
  const type = item.type,
        range = item.range,
        date = item.date,
        fromnow = item.fromnow,
        unit = item.unit;

  if (range === 'absolute') {
    return `${type} ${datetime(date, showTime)}`;
  }

  const fromNowAgoText = fromnow ? 'from now' : 'ago';
  return unit === 'now' ? `${type} 0 minutes ${fromNowAgoText}` : `${type} ${intervalToString(item)} ${fromNowAgoText}`;
};

const dateRange = ({
  start,
  end
}, showTime) => `${datetime(start, showTime)} to ${datetime(end, showTime)}`;

const thisRange = ({
  startInterval,
  endInterval
}) => `this ${startInterval} to ${endInterval}`;

const intervalToString = ({
  value,
  unit
}) => `${value} ${unit}`;

const typeAndUnitToString = ({
  type,
  unit
}) => `${type} ${unit}`;

const yearToString = ({
  year
}) => `${(0, _zero_pad.zeroPad4)(year)}`;

const monthToString = ({
  year,
  month
}) => `${(0, _zero_pad.zeroPad4)(year)}-${(0, _zero_pad.zeroPad2)(month)}`;

const dayToString = ({
  day
}) => `${day}`;

const on = ({
  date
}, showTime) => `${datetime(date, showTime && (0, _date_conversions.hasTimeFilterDateTimeModel)(date))}`;

const relative = ({
  startInterval,
  intervalType,
  endInterval
}) => `${intervalToString(startInterval)} ${intervalType} for ${intervalToString(endInterval)}`;

const pastToString = item => `${intervalToString(item)}${item.complete ? ' ago for ' + intervalToString(item) : ''}`;

const pastAgoToString = item => `${intervalToString(item)} ago`;

const notNullToString = () => `not null`;

const filterToStringMap = {
  null: _null_item_to_string.default,
  notnull: notNullToString,
  past: pastToString,
  pastAgo: pastAgoToString,
  this: typeAndUnitToString,
  next: typeAndUnitToString,
  last: typeAndUnitToString,
  year: yearToString,
  month: monthToString,
  day: dayToString,
  before: beforeAfter,
  after: beforeAfter,
  range: dateRange,
  thisRange,
  on,
  relative,
  anyvalue: () => '',
  user_attribute: _user_attribute_to_string.userAttributeToString
};

const dateToString = showTime => item => {
  const toStringFunction = filterToStringMap[item.type];
  return (toStringFunction === null || toStringFunction === void 0 ? void 0 : toStringFunction(item, showTime)) || '';
};

const dateFilterToString = (root, type) => (0, _tree_to_string.treeToString)(root, dateToString((0, _is_date_time.isDateTime)(type)));

exports.dateFilterToString = dateFilterToString;
//# sourceMappingURL=date_filter_to_string.js.map