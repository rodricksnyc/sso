import { generate } from 'pegjs';
import { getMatchesAdvancedNode } from './get_matches_advanced_node';
import { transformAST } from './transform/transform_ast';
import { userAttributeTransform } from './transform/userAttributeTransform';
import { typeToGrammar } from './type_to_grammar';

var generateParser = function () {
  var parserCache = {};
  return function (type, grammar) {
    if (!parserCache[type]) {
      parserCache[type] = generate(grammar);
    }

    return parserCache[type];
  };
}();

export var parseFilterExpression = function parseFilterExpression(type, expression, userAttributes) {
  var _typeToGrammar = typeToGrammar(type),
      grammar = _typeToGrammar.grammar,
      anyvalue = _typeToGrammar.anyvalue,
      _typeToGrammar$transf = _typeToGrammar.transform,
      transform = _typeToGrammar$transf === void 0 ? function (root) {
    return root;
  } : _typeToGrammar$transf;

  if (expression === '') {
    return anyvalue;
  }

  try {
    var parser = generateParser(type, grammar);
    var transforms = [userAttributeTransform(userAttributes), transform];
    return transformAST(parser.parse(expression, {
      Object: Object
    }), transforms);
  } catch (error) {
    return getMatchesAdvancedNode(expression);
  }
};
//# sourceMappingURL=parse_filter_expression.js.map