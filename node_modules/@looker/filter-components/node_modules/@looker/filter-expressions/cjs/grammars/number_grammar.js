"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.numberGrammar = void 0;

var _numbers = require("./common/numbers");

var _whitespace = require("./common/whitespace");

var _user_attribute_grammar = require("./user_attribute_grammar");

var grammar = "\n{ const Object = options.Object }\n\nEXPRESSION\n= LOGICAL_EXPRESSION / TERM\n\nLOGICAL_EXPRESSION\n= left:TERM _ type:LOGIC_SYMBOL _ right:EXPRESSION {\n  return {\n     type: type.toLowerCase(),\n       left:left,\n       right:right\n   }\n}\n\nTERM\n= USER_ATTRIBUTE / not:(NOT_SYMBOL SPACE)? term:(NULLS / COMP_INTERVALS / COMPARISON / TO / VALUE) {\n  const is = not ? false : true\n  return Object.assign({is:is}, term)\n} / not:(NOT_SYMBOL)?  SPACE? term:(INTERVAL) {\n  term.is = not ? false : true\n  return term\n}\n\nVALUE\n= value:number {\n  return {\n     type: '=',\n     value: [value]\n   }\n}\n\nCOMP_INTERVALS = INTERVAL_COMP1 / INTERVAL_COMP2 / INTERVAL_COMP3 / INTERVAL_COMP4\n\n/* Special rules for defining BETWEEN ranges using comparison operators with AND/OR */\n\n/* >= 7 AND <80.44 becomes (7, 80.44) */\nINTERVAL_COMP1 = \">\" first:\"=\"? _ n1:number _ \"AND\"i _ \"<\" second:\"=\"? n2:number {\n  const open = first ? \"[\" : \"(\"\n  const close = second ? \"]\" : \")\"\n  return {\n    type: 'between',\n    bounds: open + close,\n    first: first,\n    second: second,\n    low: n1,\n    high: n2\n  }\n}\n\n/* <=80.44  AND    >.1  becomes (0.01, 80.44] */\nINTERVAL_COMP2 = \"<\" first:\"=\"? _ n1:number _ \"AND\"i _ \">\" second:\"=\"? n2:number {\n  //const open = [\"(\", \"[\"][first.length-1]\n  //const close = [\")\", \"]\"][second.length-1]\n  const open = second ? \"[\" : \"(\"\n  const close = first ? \"]\" : \")\"\n  return {\n    type: 'between',\n    bounds: open + close,\n    low: n2,\n    high: n1\n  }\n}\n\n/* <= 7 OR >80.44 becomes [7, 80.44) */\nINTERVAL_COMP3 = \"<\" first:\"=\"?_ n1:number _ \"OR\"i _ \">\" second:\"=\"? n2:number {\n  const open = first ? \"[\" : \"(\"\n  const close = second ? \"]\" : \")\"\n  return {\n    type: 'between',\n    bounds: open + close,\n    low: n1,\n    high: n2,\n    is: false\n  }\n}\n\n/* >=80.44 OR <.1 becomes (0.01, 80.44]*/\nINTERVAL_COMP4 = \">\" first:\"=\"? _ n1:number _ \"OR\"i _ \"<\" second:\"=\"? n2:number {\n  const open = second ? \"[\" : \"(\"\n  const close = first ? \"]\" : \")\"\n  return {\n    type: 'between',\n    bounds: open + close,\n    low: n2,\n    high: n1,\n    is: false\n  }\n}\n\nINTERVAL\n= open:OPEN _ left:(number) _ COMMA _ right:(number) _ close:CLOSE {\n  return {\n    type: 'between',\n      bounds: open + close,\n      low: left,\n      high: right\n  }\n} / open:OPEN _ left:(number) _ COMMA _  close:CLOSE {\n      const type = open == '(' ? '>' : '>='\n      const value = [left]\n      return {type:type, value:value}\n} /  open:OPEN _  COMMA _ right:(number) _ close:CLOSE {\n      const type = close == ')' ? '<' : '<='\n      const value = [right]\n      return {type:type, value:value}\n } / \"(\" _ \"-inf\" _ COMMA _ right:(number) _ close:CLOSE {\n      const type = close == ')' ? '<' : '<='\n      const value = [right]\n      return {type:type, value:value}\n } / open:OPEN _ left:(number) _ COMMA _ \"inf\" _ \")\" {\n      const type = open == '(' ? '>' : '>='\n      const value = [left]\n      return {type:type, value:value}\n }\n\nTO\n  =  begin:$(number)? _ \"to\"i _ end:$(number)? _ {\n    if(begin && end) {\n       return {\n           type: 'between',\n           bounds: '[]',\n           low: begin,\n           high: end\n       }\n    }\n\n     if(begin) {\n       return {\n          type: '>=',\n          value: [begin.trim()]\n       }\n     }\n\n     if(end) {\n       return {\n          type: '<=',\n          value: [end.trim()]\n       }\n     }\n     expected('number before or after to')\n  }\n\n\nCOMPARISON\n = symbol:COMP_SYMBOL _ value:number {\n   return {\n      type: symbol,\n      value: [value]\n   }\n }\n\nNULLS\n = type:(\"NULL\"i) {\n     return  {\n       type: type.toLowerCase()\n     }\n   }\n\n/* SYMBOLS */\nLOGIC_SYMBOL = COMMA / OR { return \",\" }\nOR = \"OR\"i\nAND = \"AND\"i\nCOMMA = \",\"\nOPEN = \"(\" / \"[\"\nCLOSE = \")\" / \"]\"\nNOT_SYMBOL = \"NOT\"i / \"!=\" / \"<>\" { return 'not' }\nCOMP_SYMBOL = ( COMP_G / COMP_L )\nCOMP_G = (GTE / GT)\nGTE = \">=\"\nGT = \">\"\nCOMP_L = (LTE / LT)\nLTE = \"<=\"\nLT = \"<\"\n";
var numberGrammar = grammar.concat(_user_attribute_grammar.userAttribute, _numbers.numbers, _whitespace.whitespace);
exports.numberGrammar = numberGrammar;
//# sourceMappingURL=number_grammar.js.map