import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.array.index-of.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.object.assign.js";
var _excluded = ["showTooltip", "hideTooltip"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.map.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.object.from-entries.js";
import "core-js/modules/es.number.constructor.js";
import "core-js/modules/es.array.reduce.js";
import "core-js/modules/es.object.values.js";
import "core-js/modules/web.timers.js";
import React, { Fragment } from 'react';
import { DEFAULT_HEIGHT } from '@looker/visualizations-adapters';
import VisxPie from '@visx/shape/lib/shapes/Pie';
import { scaleOrdinal } from '@visx/scale';
import { Group } from '@visx/group';
import { useTooltip } from '@visx/tooltip';
import isArray from 'lodash/isArray';
import pick from 'lodash/pick';
import styled, { css } from 'styled-components';
import { useLabelWidth } from './useLabelWidth';
import { getLabelContent } from './getLabelContent';
import { getChartGeometry } from './getChartGeometry';
import { PieTooltip } from './PieTooltip';
import { PieArc } from './PieArc';
import { PieLabel } from './PieLabel';
import { PieLegend } from './PieLegend';

var generateColorScale = function generateColorScale(data, seriesConfig, dimension) {
  var dataKey = dimension.name;
  var range = isArray(seriesConfig) ? seriesConfig.map(function (s) {
    return s === null || s === void 0 ? void 0 : s.color;
  }) : data.map(function (d) {
    var _seriesConfig$d$dataK;

    return (_seriesConfig$d$dataK = seriesConfig[d[dataKey]]) === null || _seriesConfig$d$dataK === void 0 ? void 0 : _seriesConfig$d$dataK.color;
  });
  return scaleOrdinal({
    domain: data.map(function (d) {
      return d[dataKey];
    }),
    range: range
  });
};

export var Pie = function Pie(_ref) {
  var data = _ref.data,
      config = _ref.config,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? DEFAULT_HEIGHT : _ref$height,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? DEFAULT_HEIGHT : _ref$width,
      fields = _ref.fields;

  var _useTooltip = useTooltip(),
      showTooltip = _useTooltip.showTooltip,
      hideTooltip = _useTooltip.hideTooltip,
      tooltipProps = _objectWithoutProperties(_useTooltip, _excluded);

  var series = config.series,
      legend = config.legend,
      _config$tooltips = config.tooltips,
      tooltips = _config$tooltips === void 0 ? true : _config$tooltips;

  var _ref2 = legend || {},
      _ref2$position = _ref2.position,
      legendPosition = _ref2$position === void 0 ? 'right' : _ref2$position,
      legendType = _ref2.type,
      legendWidth = _ref2.width;

  var limitedData = data.slice(0, 50);
  var firstMeasure = fields.measures[0] || {};
  var firstDimension = fields.dimensions[0] || {};
  var keyValData = Object.fromEntries(limitedData.map(function (d) {
    return [d[firstDimension.name], Number(d[firstMeasure.name])];
  }));
  var measureTotal = Number(Object.values(keyValData).reduce(function (total, v) {
    return Number(total) + Number(v);
  }, 0));
  var labelWidth = useLabelWidth(measureTotal, keyValData, legend);

  var _getChartGeometry = getChartGeometry({
    legendType: legend ? legend.type : undefined,
    width: width,
    height: height,
    labelWidth: labelWidth
  }),
      canvasW = _getChartGeometry.canvasW,
      canvasH = _getChartGeometry.canvasH,
      pieCenterX = _getChartGeometry.pieCenterX,
      pieCenterY = _getChartGeometry.pieCenterY,
      outerRadius = _getChartGeometry.outerRadius;

  var colorScale = generateColorScale(limitedData, series, firstDimension);
  var mouseOutTimer = 0;

  var handleMouseOver = function handleMouseOver(_ref3, coords) {
    var pieDatum = _ref3.data;
    window.clearTimeout(mouseOutTimer);

    if (coords && tooltips) {
      showTooltip({
        tooltipData: pieDatum,
        tooltipTop: coords.y,
        tooltipLeft: coords.x
      });
    }
  };

  var handleMouseOut = function handleMouseOut() {
    mouseOutTimer = window.setTimeout(function () {
      hideTooltip();
    });
  };

  return React.createElement(React.Fragment, null, React.createElement(PieGrid, {
    legendType: legend ? legend.type : undefined
  }, React.createElement(PieChart, {
    legendPosition: legendPosition,
    width: canvasW,
    height: canvasH
  }, React.createElement(Group, {
    top: pieCenterY,
    left: pieCenterX
  }, React.createElement(VisxPie, {
    data: limitedData,
    pieValue: function pieValue(d) {
      return d[firstMeasure.name];
    },
    pieSortValues: function pieSortValues() {
      return 1;
    },
    outerRadius: outerRadius
  }, function (_ref4) {
    var arcs = _ref4.arcs,
        path = _ref4.path;
    return arcs.map(function (arc, i) {
      var dimensonValue = arc.data[firstDimension.name];
      var arcDatum = pick(keyValData, dimensonValue);
      var datumColor = colorScale(dimensonValue) || '#000000';
      return React.createElement(Fragment, {
        key: i
      }, React.createElement(PieArc, {
        arc: arc,
        path: path,
        key: i,
        datumColor: datumColor,
        onMouseOver: handleMouseOver,
        onMouseOut: handleMouseOut,
        renderTooltip: tooltips
      }), legendType === 'labels' && React.createElement(PieLabel, {
        arc: arc,
        outerRadius: outerRadius,
        labelContent: getLabelContent(measureTotal, arcDatum, legend),
        datumColor: datumColor
      }));
    });
  }))), legend && legendType === 'legend' && React.createElement(LegendWrapper, {
    legendPosition: legendPosition
  }, React.createElement(PieLegend, {
    legendConfig: legend,
    scale: colorScale,
    data: keyValData,
    measureTotal: measureTotal,
    height: canvasH,
    width: legendWidth || canvasW
  }))), React.createElement(PieTooltip, _extends({}, tooltipProps, {
    measure: firstMeasure,
    dimension: firstDimension
  })));
};
var PieGrid = styled.div.withConfig({
  displayName: "Pie__PieGrid",
  componentId: "sc-98dgxh-0"
})(["align-items:center;display:grid;grid-column-gap:", ";grid-template-areas:'top top' 'left right' 'bottom bottom';grid-template-columns:fit-content(250px) 1fr;"], function (_ref5) {
  var theme = _ref5.theme,
      legendType = _ref5.legendType;
  return legendType === 'legend' ? theme.space.medium : 0;
});
var PieChart = styled.svg.withConfig({
  displayName: "Pie__PieChart",
  componentId: "sc-98dgxh-1"
})(["", ""], function (_ref6) {
  var legendPosition = _ref6.legendPosition;
  return css(["grid-area:", ";"], legendPosition === "left" ? "right" : "left");
});
var LegendWrapper = styled.div.withConfig({
  displayName: "Pie__LegendWrapper",
  componentId: "sc-98dgxh-2"
})(["", ""], function (_ref7) {
  var legendPosition = _ref7.legendPosition;
  return css(["grid-area:", ";"], legendPosition);
});
//# sourceMappingURL=Pie.js.map