function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import "core-js/modules/es.string.small.js";
import "core-js/modules/es.array.is-array.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";
import React, { useState, useContext } from 'react';
import { LegendOrdinal } from '@visx/legend';
import styled, { css, ThemeContext } from 'styled-components';
import { useMeasuredElement, useCallbackRef } from '@looker/components';
import pick from 'lodash/pick';
import { useTranslation } from 'react-i18next';
import { PieLegendControls } from './PieLegendControls';
import { getLabelContent } from './getLabelContent';

var getLegendStyle = function getLegendStyle(scale, orientation, theme) {
  var domain = scale.domain();
  var rows = domain.length > 3 ? 3 : 1;
  return orientation === 'horizontal' ? {
    display: "grid",
    gridTemplateRows: "repeat(".concat(rows, ", auto )"),
    gridColumnGap: theme.space.small,
    gridAutoFlow: "column"
  } : {};
};

export var PieLegend = function PieLegend(_ref) {
  var legendConfig = _ref.legendConfig,
      scale = _ref.scale,
      data = _ref.data,
      measureTotal = _ref.measureTotal,
      height = _ref.height,
      width = _ref.width;

  var _useTranslation = useTranslation('PieLegend'),
      t = _useTranslation.t;

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      page = _useState2[0],
      setPage = _useState2[1];

  var theme = useContext(ThemeContext);

  var _ref2 = legendConfig || {},
      position = _ref2.position;

  var ORIENTATION = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';

  var _useCallbackRef = useCallbackRef(null),
      _useCallbackRef2 = _slicedToArray(_useCallbackRef, 2),
      contentElement = _useCallbackRef2[0],
      contentRef = _useCallbackRef2[1];

  var _useMeasuredElement = useMeasuredElement(contentElement),
      _useMeasuredElement2 = _slicedToArray(_useMeasuredElement, 1),
      _useMeasuredElement2$ = _useMeasuredElement2[0],
      contentHeight = _useMeasuredElement2$.height,
      contentWidth = _useMeasuredElement2$.width;

  var _useCallbackRef3 = useCallbackRef(null),
      _useCallbackRef4 = _slicedToArray(_useCallbackRef3, 2),
      containerElement = _useCallbackRef4[0],
      containerRef = _useCallbackRef4[1];

  var _useMeasuredElement3 = useMeasuredElement(containerElement),
      _useMeasuredElement4 = _slicedToArray(_useMeasuredElement3, 1),
      containerElementRect = _useMeasuredElement4[0];

  var containerHeight = typeof DOMRect === 'function' ? containerElementRect.height : height;
  var containerWidth = typeof DOMRect === 'function' ? containerElementRect.width : width;
  var pageSize = ORIENTATION === 'horizontal' ? containerWidth * 0.9 : containerHeight * 0.9;
  var totalPages = ORIENTATION === 'horizontal' ? Math.floor(contentWidth / Math.max(pageSize, 1)) : Math.floor(contentHeight / Math.max(pageSize, 1));

  var handleNextPage = function handleNextPage() {
    setPage(Math.min(page + 1, totalPages));
  };

  var handlePrevPage = function handlePrevPage() {
    setPage(Math.max(page - 1, 0));
  };

  var handleKeyDown = function handleKeyDown(e) {
    if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
      handleNextPage();
      e.preventDefault();
    }

    if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
      handlePrevPage();
      e.preventDefault();
    }
  };

  return React.createElement(LegendWrapper, {
    maxHeight: height,
    maxWidth: width,
    orientation: ORIENTATION
  }, React.createElement(LegendContent, {
    ref: containerRef,
    tabIndex: 0,
    onKeyDown: handleKeyDown,
    role: "figure",
    "aria-label": t('Legend page {{page}} of {{totalPages}}', {
      page: page + 1,
      totalPages: totalPages + 1
    })
  }, React.createElement(ContentPositioner, {
    pageNumber: page,
    pageSize: pageSize,
    orientation: ORIENTATION,
    ref: contentRef
  }, React.createElement(LegendOrdinal, {
    labelFormat: function labelFormat(label) {
      var datum = pick(data, label);
      return getLabelContent(measureTotal, datum, legendConfig);
    },
    scale: scale,
    shape: "circle",
    style: getLegendStyle(scale, ORIENTATION, theme)
  }))), React.createElement(PieLegendControls, {
    containerRect: {
      width: containerWidth,
      height: containerHeight
    },
    contentRect: {
      width: contentWidth,
      height: contentHeight
    },
    orientation: ORIENTATION,
    page: page,
    totalPages: totalPages,
    handleNextClick: handleNextPage,
    handlePrevClick: handlePrevPage
  }));
};
var LegendWrapper = styled.div.withConfig({
  displayName: "PieLegend__LegendWrapper",
  componentId: "sc-1dt2jge-0"
})(["border:1px solid transparent;display:grid;max-height:", "px;max-width:", "px;overflow:hidden;position:relative;", " width:fit-content;&:focus{border-color:", ";}"], function (_ref3) {
  var maxHeight = _ref3.maxHeight;
  return maxHeight;
}, function (_ref4) {
  var maxWidth = _ref4.maxWidth;
  return maxWidth;
}, function (_ref5) {
  var orientation = _ref5.orientation,
      theme = _ref5.theme;

  if (orientation === 'horizontal') {
    return css(["align-items:center;grid-template-columns:1fr auto;"]);
  } else {
    return css(["grid-template-rows:1fr auto;padding:", " 0;"], theme.space.medium);
  }
}, function (_ref6) {
  var theme = _ref6.theme;
  return theme.colors.key;
});
var LegendContent = styled.figure.withConfig({
  displayName: "PieLegend__LegendContent",
  componentId: "sc-1dt2jge-1"
})(["margin:0;overflow:hidden;padding:0;position:relative;.visx-legend-label{width:max-content;}"]);
var ContentPositioner = styled.div.withConfig({
  displayName: "PieLegend__ContentPositioner",
  componentId: "sc-1dt2jge-2"
})(["overflow:visible;transition:transform 300ms;width:max-content;", ""], function (_ref7) {
  var orientation = _ref7.orientation,
      pageNumber = _ref7.pageNumber,
      pageSize = _ref7.pageSize;

  if (orientation === 'horizontal') {
    return css(["transform:translateX(", "px);"], pageNumber * pageSize * -1);
  } else {
    return css(["transform:translateY(", "px);"], pageNumber * pageSize * -1);
  }
});
//# sourceMappingURL=PieLegend.js.map