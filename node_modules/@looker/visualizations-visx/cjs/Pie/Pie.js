"use strict";

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pie = void 0;

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.object.from-entries.js");

require("core-js/modules/es.object.values.js");

var _react = _interopRequireWildcard(require("react"));

var _visualizationsAdapters = require("@looker/visualizations-adapters");

var _Pie = _interopRequireDefault(require("@visx/shape/lib/shapes/Pie"));

var _scale = require("@visx/scale");

var _group = require("@visx/group");

var _tooltip = require("@visx/tooltip");

var _isArray = _interopRequireDefault(require("lodash/isArray"));

var _pick = _interopRequireDefault(require("lodash/pick"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _useLabelWidth = require("./useLabelWidth");

var _getLabelContent = require("./getLabelContent");

var _getChartGeometry2 = require("./getChartGeometry");

var _PieTooltip = require("./PieTooltip");

var _PieArc = require("./PieArc");

var _PieLabel = require("./PieLabel");

var _PieLegend = require("./PieLegend");

const _excluded = ["showTooltip", "hideTooltip"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const generateColorScale = (data, seriesConfig, dimension) => {
  const dataKey = dimension.name;
  const range = (0, _isArray.default)(seriesConfig) ? seriesConfig.map(s => s === null || s === void 0 ? void 0 : s.color) : data.map(d => {
    var _seriesConfig$d$dataK;

    return (_seriesConfig$d$dataK = seriesConfig[d[dataKey]]) === null || _seriesConfig$d$dataK === void 0 ? void 0 : _seriesConfig$d$dataK.color;
  });
  return (0, _scale.scaleOrdinal)({
    domain: data.map(d => d[dataKey]),
    range
  });
};

const Pie = ({
  data,
  config,
  height = _visualizationsAdapters.DEFAULT_HEIGHT,
  width = _visualizationsAdapters.DEFAULT_HEIGHT,
  fields
}) => {
  const _useTooltip = (0, _tooltip.useTooltip)(),
        showTooltip = _useTooltip.showTooltip,
        hideTooltip = _useTooltip.hideTooltip,
        tooltipProps = _objectWithoutProperties(_useTooltip, _excluded);

  const series = config.series,
        legend = config.legend,
        _config$tooltips = config.tooltips,
        tooltips = _config$tooltips === void 0 ? true : _config$tooltips;

  const _ref = legend || {},
        _ref$position = _ref.position,
        legendPosition = _ref$position === void 0 ? 'right' : _ref$position,
        legendType = _ref.type,
        legendWidth = _ref.width;

  const limitedData = data.slice(0, 50);
  const firstMeasure = fields.measures[0] || {};
  const firstDimension = fields.dimensions[0] || {};
  const keyValData = Object.fromEntries(limitedData.map(d => [d[firstDimension.name], Number(d[firstMeasure.name])]));
  const measureTotal = Number(Object.values(keyValData).reduce((total, v) => Number(total) + Number(v), 0));
  const labelWidth = (0, _useLabelWidth.useLabelWidth)(measureTotal, keyValData, legend);

  const _getChartGeometry = (0, _getChartGeometry2.getChartGeometry)({
    legendType: legend ? legend.type : undefined,
    width,
    height,
    labelWidth
  }),
        canvasW = _getChartGeometry.canvasW,
        canvasH = _getChartGeometry.canvasH,
        pieCenterX = _getChartGeometry.pieCenterX,
        pieCenterY = _getChartGeometry.pieCenterY,
        outerRadius = _getChartGeometry.outerRadius;

  const colorScale = generateColorScale(limitedData, series, firstDimension);
  let mouseOutTimer = 0;

  const handleMouseOver = ({
    data: pieDatum
  }, coords) => {
    window.clearTimeout(mouseOutTimer);

    if (coords && tooltips) {
      showTooltip({
        tooltipData: pieDatum,
        tooltipTop: coords.y,
        tooltipLeft: coords.x
      });
    }
  };

  const handleMouseOut = () => {
    mouseOutTimer = window.setTimeout(() => {
      hideTooltip();
    });
  };

  return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(PieGrid, {
    legendType: legend ? legend.type : undefined
  }, _react.default.createElement(PieChart, {
    legendPosition: legendPosition,
    width: canvasW,
    height: canvasH
  }, _react.default.createElement(_group.Group, {
    top: pieCenterY,
    left: pieCenterX
  }, _react.default.createElement(_Pie.default, {
    data: limitedData,
    pieValue: d => d[firstMeasure.name],
    pieSortValues: () => 1,
    outerRadius: outerRadius
  }, ({
    arcs,
    path
  }) => {
    return arcs.map((arc, i) => {
      const dimensonValue = arc.data[firstDimension.name];
      const arcDatum = (0, _pick.default)(keyValData, dimensonValue);
      const datumColor = colorScale(dimensonValue) || '#000000';
      return _react.default.createElement(_react.Fragment, {
        key: i
      }, _react.default.createElement(_PieArc.PieArc, {
        arc: arc,
        path: path,
        key: i,
        datumColor: datumColor,
        onMouseOver: handleMouseOver,
        onMouseOut: handleMouseOut,
        renderTooltip: tooltips
      }), legendType === 'labels' && _react.default.createElement(_PieLabel.PieLabel, {
        arc: arc,
        outerRadius: outerRadius,
        labelContent: (0, _getLabelContent.getLabelContent)(measureTotal, arcDatum, legend),
        datumColor: datumColor
      }));
    });
  }))), legend && legendType === 'legend' && _react.default.createElement(LegendWrapper, {
    legendPosition: legendPosition
  }, _react.default.createElement(_PieLegend.PieLegend, {
    legendConfig: legend,
    scale: colorScale,
    data: keyValData,
    measureTotal: measureTotal,
    height: canvasH,
    width: legendWidth || canvasW
  }))), _react.default.createElement(_PieTooltip.PieTooltip, _extends({}, tooltipProps, {
    measure: firstMeasure,
    dimension: firstDimension
  })));
};

exports.Pie = Pie;

const PieGrid = _styledComponents.default.div.withConfig({
  displayName: "Pie__PieGrid",
  componentId: "sc-98dgxh-0"
})(["align-items:center;display:grid;grid-column-gap:", ";grid-template-areas:'top top' 'left right' 'bottom bottom';grid-template-columns:fit-content(250px) 1fr;"], ({
  theme,
  legendType
}) => legendType === 'legend' ? theme.space.medium : 0);

const PieChart = _styledComponents.default.svg.withConfig({
  displayName: "Pie__PieChart",
  componentId: "sc-98dgxh-1"
})(["", ""], ({
  legendPosition
}) => (0, _styledComponents.css)(["grid-area:", ";"], legendPosition === `left` ? `right` : `left`));

const LegendWrapper = _styledComponents.default.div.withConfig({
  displayName: "Pie__LegendWrapper",
  componentId: "sc-98dgxh-2"
})(["", ""], ({
  legendPosition
}) => (0, _styledComponents.css)(["grid-area:", ";"], legendPosition));
//# sourceMappingURL=Pie.js.map