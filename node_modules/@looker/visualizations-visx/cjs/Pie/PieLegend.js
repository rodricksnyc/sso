"use strict";

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PieLegend = void 0;

var _react = _interopRequireWildcard(require("react"));

var _legend = require("@visx/legend");

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _components = require("@looker/components");

var _pick = _interopRequireDefault(require("lodash/pick"));

var _reactI18next = require("react-i18next");

var _PieLegendControls = require("./PieLegendControls");

var _getLabelContent = require("./getLabelContent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const getLegendStyle = (scale, orientation, theme) => {
  const domain = scale.domain();
  const rows = domain.length > 3 ? 3 : 1;
  return orientation === 'horizontal' ? {
    display: `grid`,
    gridTemplateRows: `repeat(${rows}, auto )`,
    gridColumnGap: theme.space.small,
    gridAutoFlow: `column`
  } : {};
};

const PieLegend = ({
  legendConfig,
  scale,
  data,
  measureTotal,
  height,
  width
}) => {
  const _useTranslation = (0, _reactI18next.useTranslation)('PieLegend'),
        t = _useTranslation.t;

  const _useState = (0, _react.useState)(0),
        _useState2 = _slicedToArray(_useState, 2),
        page = _useState2[0],
        setPage = _useState2[1];

  const theme = (0, _react.useContext)(_styledComponents.ThemeContext);

  const _ref = legendConfig || {},
        position = _ref.position;

  const ORIENTATION = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';

  const _useCallbackRef = (0, _components.useCallbackRef)(null),
        _useCallbackRef2 = _slicedToArray(_useCallbackRef, 2),
        contentElement = _useCallbackRef2[0],
        contentRef = _useCallbackRef2[1];

  const _useMeasuredElement = (0, _components.useMeasuredElement)(contentElement),
        _useMeasuredElement2 = _slicedToArray(_useMeasuredElement, 1),
        _useMeasuredElement2$ = _useMeasuredElement2[0],
        contentHeight = _useMeasuredElement2$.height,
        contentWidth = _useMeasuredElement2$.width;

  const _useCallbackRef3 = (0, _components.useCallbackRef)(null),
        _useCallbackRef4 = _slicedToArray(_useCallbackRef3, 2),
        containerElement = _useCallbackRef4[0],
        containerRef = _useCallbackRef4[1];

  const _useMeasuredElement3 = (0, _components.useMeasuredElement)(containerElement),
        _useMeasuredElement4 = _slicedToArray(_useMeasuredElement3, 1),
        containerElementRect = _useMeasuredElement4[0];

  const containerHeight = typeof DOMRect === 'function' ? containerElementRect.height : height;
  const containerWidth = typeof DOMRect === 'function' ? containerElementRect.width : width;
  const pageSize = ORIENTATION === 'horizontal' ? containerWidth * 0.9 : containerHeight * 0.9;
  const totalPages = ORIENTATION === 'horizontal' ? Math.floor(contentWidth / Math.max(pageSize, 1)) : Math.floor(contentHeight / Math.max(pageSize, 1));

  const handleNextPage = () => {
    setPage(Math.min(page + 1, totalPages));
  };

  const handlePrevPage = () => {
    setPage(Math.max(page - 1, 0));
  };

  const handleKeyDown = e => {
    if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
      handleNextPage();
      e.preventDefault();
    }

    if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
      handlePrevPage();
      e.preventDefault();
    }
  };

  return _react.default.createElement(LegendWrapper, {
    maxHeight: height,
    maxWidth: width,
    orientation: ORIENTATION
  }, _react.default.createElement(LegendContent, {
    ref: containerRef,
    tabIndex: 0,
    onKeyDown: handleKeyDown,
    role: "figure",
    "aria-label": t('Legend page {{page}} of {{totalPages}}', {
      page: page + 1,
      totalPages: totalPages + 1
    })
  }, _react.default.createElement(ContentPositioner, {
    pageNumber: page,
    pageSize: pageSize,
    orientation: ORIENTATION,
    ref: contentRef
  }, _react.default.createElement(_legend.LegendOrdinal, {
    labelFormat: label => {
      const datum = (0, _pick.default)(data, label);
      return (0, _getLabelContent.getLabelContent)(measureTotal, datum, legendConfig);
    },
    scale: scale,
    shape: "circle",
    style: getLegendStyle(scale, ORIENTATION, theme)
  }))), _react.default.createElement(_PieLegendControls.PieLegendControls, {
    containerRect: {
      width: containerWidth,
      height: containerHeight
    },
    contentRect: {
      width: contentWidth,
      height: contentHeight
    },
    orientation: ORIENTATION,
    page: page,
    totalPages: totalPages,
    handleNextClick: handleNextPage,
    handlePrevClick: handlePrevPage
  }));
};

exports.PieLegend = PieLegend;

const LegendWrapper = _styledComponents.default.div.withConfig({
  displayName: "PieLegend__LegendWrapper",
  componentId: "sc-1dt2jge-0"
})(["border:1px solid transparent;display:grid;max-height:", "px;max-width:", "px;overflow:hidden;position:relative;", " width:fit-content;&:focus{border-color:", ";}"], ({
  maxHeight
}) => maxHeight, ({
  maxWidth
}) => maxWidth, ({
  orientation,
  theme
}) => {
  if (orientation === 'horizontal') {
    return (0, _styledComponents.css)(["align-items:center;grid-template-columns:1fr auto;"]);
  } else {
    return (0, _styledComponents.css)(["grid-template-rows:1fr auto;padding:", " 0;"], theme.space.medium);
  }
}, ({
  theme
}) => theme.colors.key);

const LegendContent = _styledComponents.default.figure.withConfig({
  displayName: "PieLegend__LegendContent",
  componentId: "sc-1dt2jge-1"
})(["margin:0;overflow:hidden;padding:0;position:relative;.visx-legend-label{width:max-content;}"]);

const ContentPositioner = _styledComponents.default.div.withConfig({
  displayName: "PieLegend__ContentPositioner",
  componentId: "sc-1dt2jge-2"
})(["overflow:visible;transition:transform 300ms;width:max-content;", ""], ({
  orientation,
  pageNumber,
  pageSize
}) => {
  if (orientation === 'horizontal') {
    return (0, _styledComponents.css)(["transform:translateX(", "px);"], pageNumber * pageSize * -1);
  } else {
    return (0, _styledComponents.css)(["transform:translateY(", "px);"], pageNumber * pageSize * -1);
  }
});
//# sourceMappingURL=PieLegend.js.map