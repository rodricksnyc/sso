"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Glyph = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = require("styled-components");

var _glyph = require("@visx/glyph");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Glyphs = {
  circle: _glyph.GlyphCircle,
  square: _glyph.GlyphSquare,
  diamond: _glyph.GlyphDiamond,
  triangle: _glyph.GlyphTriangle,
  'triangle-down': _glyph.GlyphTriangle
};

const Glyph = ({
  series,
  top,
  left,
  size,
  fill,
  styleObj,
  stroke
}) => {
  const theme = (0, _react.useContext)(_styledComponents.ThemeContext);
  const _series$shape = series.shape,
        shape = _series$shape === void 0 ? 'circle' : _series$shape,
        _series$line_width = series.line_width,
        line_width = _series$line_width === void 0 ? 1 : _series$line_width;
  const CurrGlyph = Glyphs[shape];

  const strokeWidth = () => {
    switch (true) {
      case line_width < 3:
        return line_width;

      case line_width < 8:
        return line_width * 0.75;

      default:
        return line_width * 0.5;
    }
  };

  const renderedStroke = stroke || series.color || theme.colors.key;
  return _react.default.createElement(CurrGlyph, {
    top: top,
    left: left,
    size: size,
    fill: fill || theme.colors.key,
    transform: shape === `triangle-down` ? `rotate(180)` : ``,
    style: styleObj || {},
    stroke: stroke === false ? undefined : renderedStroke,
    strokeWidth: strokeWidth()
  });
};

exports.Glyph = Glyph;
//# sourceMappingURL=Glyph.js.map