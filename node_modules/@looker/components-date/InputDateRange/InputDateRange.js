function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import "core-js/modules/es.date.to-string.js";
import "core-js/modules/es.date.now.js";
import "core-js/modules/es.number.constructor.js";
import "core-js/modules/es.array.reduce.js";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.array.is-array.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";
import "core-js/modules/es.object.define-property.js";
import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.object.get-own-property-descriptor.js";
import "core-js/modules/es.array.for-each.js";
import "core-js/modules/web.dom-collections.for-each.js";
import "core-js/modules/es.object.get-own-property-descriptors.js";
import "core-js/modules/es.object.define-properties.js";
import React, { useState, useEffect, forwardRef } from 'react';
import styled from 'styled-components';
import isFunction from 'lodash/isFunction';
import partial from 'lodash/partial';
import min from 'lodash/min';
import max from 'lodash/max';
import isEmpty from 'lodash/isEmpty';
import isEqual from 'lodash/isEqual';
import values from 'lodash/values';
import { useTranslation } from 'react-i18next';
import { inputCSS, inputHeight, InputTextContent, InlineInputTextBase, inputTextHover, inputTextFocus, inputTextValidation, inputTextDisabled, ErrorIcon, VisuallyHidden, useID, useReadOnlyWarn } from '@looker/components';
import { Calendar, formatMonthTitle } from '../Calendar';
import { formatDateString, parseDateFromString } from '../locale';

var transformMonth = function transformMonth() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date(Date.now());
  var monthDiff = arguments.length > 1 ? arguments[1] : undefined;
  var newDate = new Date(date);
  newDate.setDate(1);
  newDate.setMonth(newDate.getMonth() + monthDiff);
  return newDate;
};

var chooseDatesToSet = function chooseDatesToSet(activeDateInput, newDate) {
  var dateRange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var from = dateRange.from,
      to = dateRange.to;

  if (newDate) {
    if (isEmpty(dateRange) || Number(newDate) === Number(from) || Number(newDate) === Number(to)) {
      return ['to', 'from'];
    } else if (from && newDate < from) {
      return ['from'];
    } else if (to && newDate > to) {
      return ['to'];
    }
  }

  return [activeDateInput];
};

var isDateRangeInView = function isDateRangeInView(dateRange, viewMonth) {
  if (!dateRange.from || !dateRange.to) {
    return false;
  }

  var monthOneTimestamp = viewMonth.getTime();
  var monthTwoTimestamp = transformMonth(viewMonth, 2).getTime();
  var fromTimestamp = dateRange.from.getTime();
  var toTimestamp = dateRange.to.getTime();

  if (fromTimestamp < monthOneTimestamp || toTimestamp >= monthTwoTimestamp) {
    return false;
  }

  return true;
};

export var InputDateRange = forwardRef(function (_ref, ref) {
  var ariaLabelledby = _ref['aria-labelledby'],
      dateStringFormat = _ref.dateStringFormat,
      _ref$defaultValue = _ref.defaultValue,
      defaultValue = _ref$defaultValue === void 0 ? {} : _ref$defaultValue,
      disabled = _ref.disabled,
      firstDayOfWeek = _ref.firstDayOfWeek,
      id = _ref.id,
      locale = _ref.locale,
      onChange = _ref.onChange,
      onValidationFail = _ref.onValidationFail,
      readOnly = _ref.readOnly,
      validationType = _ref.validationType,
      value = _ref.value;
  useReadOnlyWarn('InputDateRange', value, onChange);

  var _useState = useState(value || defaultValue),
      _useState2 = _slicedToArray(_useState, 2),
      dateRange = _useState2[0],
      setDateRange = _useState2[1];

  var _useState3 = useState('from'),
      _useState4 = _slicedToArray(_useState3, 2),
      activeDateInput = _useState4[0],
      setActiveDateInput = _useState4[1];

  var calView = new Date(Date.now());

  if (value && value.from) {
    calView = value.from;
  } else if (defaultValue && defaultValue.from) {
    calView = defaultValue.from;
  }

  var _useState5 = useState(calView),
      _useState6 = _slicedToArray(_useState5, 2),
      viewMonth = _useState6[0],
      setViewMonth = _useState6[1];

  var viewNextMonth = new Date(viewMonth);
  viewNextMonth.setMonth(viewNextMonth.getMonth() + 1);

  var _useState7 = useState(formatDateString(dateRange.from, locale, dateStringFormat)),
      _useState8 = _slicedToArray(_useState7, 2),
      fromTextInputValue = _useState8[0],
      setFromTextInputValue = _useState8[1];

  var _useState9 = useState(validationType !== 'error'),
      _useState10 = _slicedToArray(_useState9, 2),
      validFromDate = _useState10[0],
      setValidFromDate = _useState10[1];

  var fromID = useID(id && "from-".concat(id));

  var _useState11 = useState(formatDateString(dateRange.to, locale, dateStringFormat)),
      _useState12 = _slicedToArray(_useState11, 2),
      toTextInputValue = _useState12[0],
      setToTextInputValue = _useState12[1];

  var _useState13 = useState(validationType !== 'error'),
      _useState14 = _slicedToArray(_useState13, 2),
      validToDate = _useState14[0],
      setValidToDate = _useState14[1];

  var toID = useID(id && "to-".concat(id));
  var inputs = {
    from: {
      isValid: validFromDate,
      setIsValid: setValidFromDate,
      setValue: setFromTextInputValue,
      value: fromTextInputValue
    },
    to: {
      isValid: validToDate,
      setIsValid: setValidToDate,
      setValue: setToTextInputValue,
      value: toTextInputValue
    }
  };
  useEffect(function () {
    if (value && !isEqual(value, dateRange)) {
      setDateRange(value);
      value.from && inputs.from.setValue(formatDateString(value.from, locale, dateStringFormat));
      value.to && inputs.to.setValue(formatDateString(value.to, locale, dateStringFormat));
      value.from && !isDateRangeInView(value, viewMonth) && setViewMonth(value.from);
    }
  }, [inputs.from, inputs.to, value, onChange]);

  var toggleActiveDateInput = function toggleActiveDateInput() {
    if (activeDateInput === 'from') {
      setActiveDateInput('to');
    } else {
      setActiveDateInput('from');
    }
  };

  var handleDateChange = function handleDateChange(datesToSet, date) {
    var newDateRange = _objectSpread(_objectSpread({}, dateRange), datesToSet.reduce(function (r, endpoint) {
      return _objectSpread(_objectSpread({}, r), {}, _defineProperty({}, endpoint, date));
    }, {}));

    if (activeDateInput === 'from') {
      newDateRange.to = max(values(newDateRange));
      newDateRange.from = min(values(newDateRange));
    } else {
      newDateRange.from = min(values(newDateRange));
      newDateRange.to = max(values(newDateRange));
    }

    var nonActiveInput = datesToSet[0] === 'from' ? 'to' : 'from';
    inputs[nonActiveInput].setValue(formatDateString(newDateRange[nonActiveInput], locale, dateStringFormat));

    if (!validationType) {
      inputs.from.isValid || inputs.from.setIsValid(true);
      inputs.to.isValid || inputs.to.setIsValid(true);
    }

    setDateRange(newDateRange);

    if (isFunction(onChange)) {
      onChange(newDateRange);
    }
  };

  var handleCalendarClick = function handleCalendarClick(date) {
    var datesToSet = chooseDatesToSet(activeDateInput, date, dateRange);

    var _iterator = _createForOfIteratorHelper(datesToSet),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var d = _step.value;
        inputs[d].setValue(formatDateString(date, locale, dateStringFormat));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (datesToSet[0] === activeDateInput && datesToSet.length === 1) {
      toggleActiveDateInput();
    }

    handleDateChange(datesToSet, date);
  };

  var handleTextInputChange = function handleTextInputChange(e) {
    var value = e.target.value;
    inputs[activeDateInput].setValue(value);

    if (value.length === 0) {
      var inactiveDateInput = activeDateInput === 'from' ? 'to' : 'from';

      if (inputs[inactiveDateInput].value === '') {
        handleDateChange([activeDateInput, inactiveDateInput]);
      } else {
        handleDateChange([activeDateInput]);
      }
    } else {
      var parsedValue = parseDateFromString(value, locale, dateStringFormat);

      if (parsedValue) {
        var newMonthFocus = activeDateInput === 'to' ? transformMonth(parsedValue, -1) : parsedValue;
        setViewMonth(newMonthFocus);
        handleDateChange([activeDateInput], parsedValue);
      }
    }
  };

  var handleValidation = function handleValidation(e) {
    if (!validationType) {
      var _value = e.target.value;
      var isValid = _value.length === 0 || !!parseDateFromString(_value, locale, dateStringFormat);
      inputs[activeDateInput].setIsValid(isValid);

      if (!isValid && isFunction(onValidationFail)) {
        onValidationFail(_value);
      }
    }
  };

  var handleNextClick = function handleNextClick() {
    setViewMonth(transformMonth(viewMonth, 1));
  };

  var handlePrevClick = function handlePrevClick() {
    setViewMonth(transformMonth(viewMonth, -1));
  };

  var handleNowClick = function handleNowClick() {
    setViewMonth(new Date(Date.now()));
  };

  var handleTextInputFocus = function handleTextInputFocus(label) {
    return setActiveDateInput(label);
  };

  var handleMonthChange = function handleMonthChange(viewMonthDiff, month) {
    setViewMonth(transformMonth(month, viewMonthDiff));
  };

  var _useTranslation = useTranslation('InputDateRange'),
      t = _useTranslation.t;

  var startDateLabelledby = "startDate-labelledby-".concat(id);
  var endDateLabelledby = "endDate-labelledby-".concat(id);

  var _formatMonthTitle = formatMonthTitle(locale);

  var monthTitle = "".concat(_formatMonthTitle(viewMonth), " ").concat(_formatMonthTitle(viewNextMonth));
  return React.createElement(InputDateRangeWrapper, {
    ref: ref
  }, React.createElement(InputTextGroupWrapper, {
    disabled: disabled,
    active: activeDateInput === 'from',
    validationType: inputs.from.isValid && inputs.to.isValid ? undefined : 'error'
  }, React.createElement(VisuallyHidden, {
    id: startDateLabelledby
  }, t('Start date')), React.createElement(InlineInputTextBase, {
    placeholder: "".concat(formatDateString(new Date(Date.now()), locale, dateStringFormat)),
    disabled: disabled,
    "data-testid": "date-from-text-input",
    fontSize: "small",
    id: fromID,
    onBlur: handleValidation,
    onChange: handleTextInputChange,
    onFocus: partial(handleTextInputFocus, 'from'),
    readOnly: readOnly,
    value: inputs.from.value,
    "aria-labelledby": "".concat(ariaLabelledby, " ").concat(startDateLabelledby)
  }), React.createElement(HyphenWrapper, {
    hasInputValues: !isEmpty(dateRange),
    "aria-hidden": "true"
  }, "\u2013"), React.createElement(VisuallyHidden, {
    id: endDateLabelledby
  }, t('End date')), React.createElement(InlineInputTextBase, {
    placeholder: formatDateString(new Date(Date.now()), locale, dateStringFormat),
    disabled: disabled,
    fontSize: "small",
    "data-testid": "date-to-text-input",
    id: toID,
    onBlur: handleValidation,
    onChange: handleTextInputChange,
    onFocus: partial(handleTextInputFocus, 'to'),
    readOnly: readOnly,
    value: inputs.to.value,
    "aria-labelledby": "".concat(ariaLabelledby, " ").concat(endDateLabelledby)
  }), inputs.from.isValid && inputs.to.isValid || React.createElement(InputTextContent, {
    pr: "u2"
  }, React.createElement(ErrorIcon, null))), React.createElement(MultiCalendarLayout, null, React.createElement(VisuallyHidden, {
    "aria-live": "assertive"
  }, monthTitle), React.createElement(CalendarWrapper, null, React.createElement(Calendar, {
    disabled: disabled,
    locale: locale,
    firstDayOfWeek: firstDayOfWeek,
    onDayClick: handleCalendarClick,
    onMonthChange: partial(handleMonthChange, 0),
    onNowClick: handleNowClick,
    onPrevClick: handlePrevClick,
    readOnly: readOnly,
    selectedDates: dateRange,
    showNextButton: false,
    viewMonth: viewMonth
  })), React.createElement(CalendarWrapper, null, React.createElement(Calendar, {
    disabled: disabled,
    locale: locale,
    firstDayOfWeek: firstDayOfWeek,
    onDayClick: handleCalendarClick,
    onMonthChange: partial(handleMonthChange, -1),
    onNextClick: handleNextClick,
    onNowClick: handleNowClick,
    readOnly: readOnly,
    selectedDates: dateRange,
    showPreviousButton: false,
    viewMonth: viewNextMonth
  }))));
});
InputDateRange.displayName = 'InputDateRange';
var HyphenWrapper = styled.div.withConfig({
  displayName: "InputDateRange__HyphenWrapper",
  componentId: "sc-19erkyb-0"
})(["align-items:center;color:", ";display:flex;.label-down &{display:none;}"], function (_ref2) {
  var theme = _ref2.theme,
      hasInputValues = _ref2.hasInputValues;
  return hasInputValues ? theme.colors.text3 : theme.colors.text1;
});
var InputDateRangeWrapper = styled.div.withConfig({
  displayName: "InputDateRange__InputDateRangeWrapper",
  componentId: "sc-19erkyb-1"
})(["width:100%;@media screen and (max-width:", "){display:grid;justify-items:center;}"], function (_ref3) {
  var theme = _ref3.theme;
  return theme.breakpoints[1];
});
var MultiCalendarLayout = styled.div.withConfig({
  displayName: "InputDateRange__MultiCalendarLayout",
  componentId: "sc-19erkyb-2"
})(["display:inline-grid;grid-column-gap:", ";grid-row-gap:", ";grid-template-columns:1fr 1fr;@media screen and (max-width:", "){grid-template-columns:1fr;margin:0 auto;}"], function (_ref4) {
  var theme = _ref4.theme;
  return theme.space.u5;
}, function (_ref5) {
  var theme = _ref5.theme;
  return theme.space.u4;
}, function (_ref6) {
  var theme = _ref6.theme;
  return theme.breakpoints[1];
});
var InputTextGroupWrapper = styled.div.withConfig({
  displayName: "InputDateRange__InputTextGroupWrapper",
  componentId: "sc-19erkyb-3"
})(["", " align-items:stretch;display:grid;font-family:", ";grid-template-columns:auto auto auto 1fr;height:", ";padding:", ";width:100%;&:hover{", "}&:focus-within{", "}", " ", " ", "{justify-self:right;}input{font-family:inherit;}", "{margin:", " 0;&:focus-within{background:", ";}input,span{padding:0 ", ";}}"], inputCSS, function (_ref7) {
  var theme = _ref7.theme;
  return theme.fonts.body;
}, inputHeight, function (_ref8) {
  var space = _ref8.theme.space;
  return "".concat(space.u05, " ").concat(space.u1);
}, inputTextHover, inputTextFocus, inputTextValidation, function (_ref9) {
  var disabled = _ref9.disabled;
  return disabled && inputTextDisabled;
}, InputTextContent, InlineInputTextBase, function (_ref10) {
  var theme = _ref10.theme;
  return theme.space.u05;
}, function (_ref11) {
  var theme = _ref11.theme;
  return theme.colors.keyAccent;
}, function (_ref12) {
  var theme = _ref12.theme;
  return theme.space.u2;
});
var CalendarWrapper = styled.div.withConfig({
  displayName: "InputDateRange__CalendarWrapper",
  componentId: "sc-19erkyb-4"
})(["", "{padding:0;}"], Calendar);
//# sourceMappingURL=InputDateRange.js.map